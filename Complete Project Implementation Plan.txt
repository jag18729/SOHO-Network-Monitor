# Vandine Network Monitor - Complete Project Implementation Plan

## Project Overview
A comprehensive network monitoring solution combining Django, FastAPI, PostgreSQL, Redis, Celery, and Docker, with real-time metrics, network device management via Netmiko, and a modern dashboard.

## Project Structure
```
vandine-network-monitor/
â”œâ”€â”€ .github/
â”‚   â””â”€â”€ workflows/
â”‚       â”œâ”€â”€ ci.yml
â”‚       â””â”€â”€ deploy.yml
â”œâ”€â”€ docker/
â”‚   â”œâ”€â”€ django/
â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”œâ”€â”€ fastapi/
â”‚   â”‚   â””â”€â”€ Dockerfile
â”‚   â”œâ”€â”€ nginx/
â”‚   â”‚   â”œâ”€â”€ Dockerfile
â”‚   â”‚   â””â”€â”€ nginx.conf
â”‚   â””â”€â”€ postgres/
â”‚       â””â”€â”€ init.sql
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ django_app/
â”‚   â”‚   â”œâ”€â”€ vandine_monitor/
â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ __init__.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ development.py
â”‚   â”‚   â”‚   â”‚   â””â”€â”€ production.py
â”‚   â”‚   â”‚   â”œâ”€â”€ urls.py
â”‚   â”‚   â”‚   â”œâ”€â”€ wsgi.py
â”‚   â”‚   â”‚   â”œâ”€â”€ asgi.py
â”‚   â”‚   â”‚   â””â”€â”€ celery.py
â”‚   â”‚   â”œâ”€â”€ apps/
â”‚   â”‚   â”‚   â”œâ”€â”€ dashboard/
â”‚   â”‚   â”‚   â”œâ”€â”€ network_monitor/
â”‚   â”‚   â”‚   â””â”€â”€ api/
â”‚   â”‚   â”œâ”€â”€ static/
â”‚   â”‚   â”œâ”€â”€ media/
â”‚   â”‚   â”œâ”€â”€ templates/
â”‚   â”‚   â””â”€â”€ requirements.txt
â”‚   â””â”€â”€ fastapi_app/
â”‚       â”œâ”€â”€ app/
â”‚       â”‚   â”œâ”€â”€ __init__.py
â”‚       â”‚   â”œâ”€â”€ main.py
â”‚       â”‚   â”œâ”€â”€ api/
â”‚       â”‚   â”œâ”€â”€ core/
â”‚       â”‚   â”œâ”€â”€ models/
â”‚       â”‚   â””â”€â”€ services/
â”‚       â””â”€â”€ requirements.txt
â”œâ”€â”€ scripts/
â”‚   â”œâ”€â”€ init_db.sh
â”‚   â”œâ”€â”€ populate_data.py
â”‚   â””â”€â”€ backup.sh
â”œâ”€â”€ tests/
â”‚   â”œâ”€â”€ django/
â”‚   â””â”€â”€ fastapi/
â”œâ”€â”€ monitoring/
â”‚   â”œâ”€â”€ prometheus/
â”‚   â””â”€â”€ grafana/
â”œâ”€â”€ .claude/
â”‚   â””â”€â”€ project_config.yml
â”œâ”€â”€ .env.example
â”œâ”€â”€ .gitignore
â”œâ”€â”€ docker-compose.yml
â”œâ”€â”€ docker-compose.dev.yml
â”œâ”€â”€ docker-compose.prod.yml
â”œâ”€â”€ Makefile
â”œâ”€â”€ README.md
â””â”€â”€ LICENSE
```

## Implementation Steps

### Phase 1: Project Setup and Configuration

#### 1.1 Initialize Git Repository
```bash
# Create project directory
mkdir vandine-network-monitor
cd vandine-network-monitor

# Initialize git
git init
git branch -M main

# Create initial structure
mkdir -p .github/workflows docker/{django,fastapi,nginx,postgres} \
         src/{django_app,fastapi_app} scripts tests monitoring/{prometheus,grafana}
```

#### 1.2 Create .gitignore
```gitignore
# Python
__pycache__/
*.py[cod]
*$py.class
*.so
.Python
env/
venv/
ENV/
VENV/
.venv
pip-log.txt
pip-delete-this-directory.txt
.pytest_cache/
*.log
*.pot
*.pyc
*.pyo
*.pyd
.coverage
.coverage.*
coverage.xml
*.cover
.hypothesis/
.mypy_cache/
.dmypy.json
dmypy.json

# Django
*.sqlite3
*.sqlite3-journal
/media
/staticfiles
/static_root
local_settings.py
db.sqlite3
db.sqlite3-journal

# Environment
.env
.env.*
!.env.example

# IDE
.idea/
.vscode/
*.swp
*.swo
*~
.DS_Store

# Docker
.docker/

# Logs
logs/
*.log

# Backups
backups/
*.bak

# Certificates
*.pem
*.key
*.crt
*.csr

# Node (for any frontend assets)
node_modules/
npm-debug.log
yarn-error.log

# Testing
htmlcov/
.tox/
.coverage
.cache
nosetests.xml
coverage.xml
*.cover
test-results/

# Claude
.claude/secrets.yml
```

#### 1.3 Create .env.example
```env
# Application
DEBUG=False
SECRET_KEY=your-secret-key-here
ALLOWED_HOSTS=vandine.us,www.vandine.us,localhost

# Database
POSTGRES_DB=vandine_db
POSTGRES_USER=vandine_user
POSTGRES_PASSWORD=secure-password-here
POSTGRES_HOST=postgres
POSTGRES_PORT=5432

# Redis
REDIS_HOST=redis
REDIS_PORT=6379
REDIS_PASSWORD=redis-password-here

# Celery
CELERY_BROKER_URL=redis://:${REDIS_PASSWORD}@${REDIS_HOST}:${REDIS_PORT}/0
CELERY_RESULT_BACKEND=redis://:${REDIS_PASSWORD}@${REDIS_HOST}:${REDIS_PORT}/0

# Network Devices
PI0_HOST=192.168.2.10
PI0_USERNAME=username
PI0_PASSWORD=password

PI1_HOST=192.168.2.7
PI1_USERNAME=username
PI1_PASSWORD=password

ROUTER_HOST=192.168.2.1
ROUTER_USERNAME=admin
ROUTER_PASSWORD=password

# Cloudflare Tunnel
TUNNEL_ID=153cc7a6-9ab5-4172-b4cc-eb21e5b524cd
TUNNEL_METRICS_URL=http://localhost:20241/metrics

# Email
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_HOST_USER=your-email@gmail.com
EMAIL_HOST_PASSWORD=your-app-password
EMAIL_USE_TLS=True
DEFAULT_FROM_EMAIL=noreply@vandine.us

# Monitoring
PROMETHEUS_ENABLED=True
GRAFANA_ENABLED=True

# API Keys
DJANGO_SUPERUSER_USERNAME=admin
DJANGO_SUPERUSER_EMAIL=admin@vandine.us
DJANGO_SUPERUSER_PASSWORD=admin-password-here
```

#### 1.4 Create .claude/project_config.yml
```yaml
project:
  name: "Vandine Network Monitor"
  description: "Comprehensive network monitoring solution with Django, FastAPI, and real-time metrics"
  version: "1.0.0"
  
architecture:
  backend:
    - framework: Django
      purpose: "Main web application, ORM, admin interface"
    - framework: FastAPI
      purpose: "High-performance API, WebSocket connections, real-time data"
    - framework: Celery
      purpose: "Background tasks, scheduled monitoring jobs"
  
  database:
    - PostgreSQL: "Primary data store"
    - Redis: "Cache, message broker, session store"
  
  monitoring:
    - Prometheus: "Metrics collection"
    - Grafana: "Visualization"
    - Custom Dashboard: "Django-based monitoring interface"

features:
  - "Real-time system metrics monitoring"
  - "Network device discovery and scanning"
  - "SSH device management via Netmiko"
  - "Cloudflare Tunnel integration"
  - "Performance testing with iPerf3"
  - "Alert system with email notifications"
  - "RESTful API with FastAPI"
  - "WebSocket support for live updates"
  - "Docker containerization"
  - "CI/CD with GitHub Actions"

development_guidelines:
  code_style: "PEP 8 for Python, clean and simple"
  naming_conventions:
    files: "lowercase_with_underscores.py"
    classes: "PascalCase"
    functions: "lowercase_with_underscores"
    constants: "UPPERCASE_WITH_UNDERSCORES"
  
  testing:
    - "Pytest for unit tests"
    - "Coverage target: 80%"
    - "Integration tests for API endpoints"
  
  documentation:
    - "Docstrings for all classes and functions"
    - "README with setup instructions"
    - "API documentation with FastAPI automatic docs"

deployment:
  environments:
    - development: "Docker Compose local"
    - staging: "Docker Compose on Pi"
    - production: "Docker with Cloudflare Tunnel"
  
  ci_cd:
    - "GitHub Actions for testing"
    - "Automated Docker builds"
    - "Deployment via SSH to Raspberry Pi"

prompting_instructions:
  - "Always include error handling and logging"
  - "Use type hints in Python code"
  - "Follow Django best practices"
  - "Keep functions small and focused"
  - "Write comprehensive docstrings"
  - "Include unit tests with new features"
  - "Use environment variables for configuration"
  - "Implement proper security measures"
```

### Phase 2: Docker Configuration

#### 2.1 Main docker-compose.yml
```yaml
version: '3.8'

x-common-variables: &common-variables
  POSTGRES_DB: ${POSTGRES_DB}
  POSTGRES_USER: ${POSTGRES_USER}
  POSTGRES_PASSWORD: ${POSTGRES_PASSWORD}
  REDIS_PASSWORD: ${REDIS_PASSWORD}

services:
  postgres:
    image: postgres:15-alpine
    container_name: vandine_postgres
    environment:
      <<: *common-variables
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./docker/postgres/init.sql:/docker-entrypoint-initdb.d/init.sql
    ports:
      - "5432:5432"
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U ${POSTGRES_USER}"]
      interval: 10s
      timeout: 5s
      retries: 5

  redis:
    image: redis:7-alpine
    container_name: vandine_redis
    command: redis-server --requirepass ${REDIS_PASSWORD}
    ports:
      - "6379:6379"
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 10s
      timeout: 5s
      retries: 5

  django:
    build:
      context: .
      dockerfile: docker/django/Dockerfile
    container_name: vandine_django
    environment:
      <<: *common-variables
    volumes:
      - ./src/django_app:/app
      - static_volume:/app/staticfiles
      - media_volume:/app/media
    ports:
      - "8000:8000"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: gunicorn vandine_monitor.wsgi:application --bind 0.0.0.0:8000

  fastapi:
    build:
      context: .
      dockerfile: docker/fastapi/Dockerfile
    container_name: vandine_fastapi
    environment:
      <<: *common-variables
    volumes:
      - ./src/fastapi_app:/app
    ports:
      - "8001:8001"
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: uvicorn app.main:app --host 0.0.0.0 --port 8001 --reload

  celery:
    build:
      context: .
      dockerfile: docker/django/Dockerfile
    container_name: vandine_celery
    environment:
      <<: *common-variables
    volumes:
      - ./src/django_app:/app
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: celery -A vandine_monitor worker -l info

  celery-beat:
    build:
      context: .
      dockerfile: docker/django/Dockerfile
    container_name: vandine_celery_beat
    environment:
      <<: *common-variables
    volumes:
      - ./src/django_app:/app
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    command: celery -A vandine_monitor beat -l info

  nginx:
    build:
      context: .
      dockerfile: docker/nginx/Dockerfile
    container_name: vandine_nginx
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - static_volume:/static
      - media_volume:/media
      - ./docker/nginx/nginx.conf:/etc/nginx/conf.d/default.conf
    depends_on:
      - django
      - fastapi

volumes:
  postgres_data:
  static_volume:
  media_volume:
```

### Phase 3: Application Code Structure

#### 3.1 Django Application Structure
- **Models**: Device tracking, metrics, alerts
- **Views**: Dashboard, API endpoints, WebSocket handlers
- **Tasks**: Celery tasks for monitoring
- **Management Commands**: Data population, cleanup

#### 3.2 FastAPI Application Structure
- **Endpoints**: High-performance API routes
- **WebSocket**: Real-time metric streaming
- **Services**: Netmiko integration, metric collection
- **Models**: Pydantic schemas for validation

### Phase 4: Makefile for Easy Management
```makefile
.PHONY: help build up down logs shell migrate test

help:
	@echo "Available commands:"
	@echo "  make build    - Build Docker images"
	@echo "  make up       - Start all services"
	@echo "  make down     - Stop all services"
	@echo "  make logs     - View logs"
	@echo "  make shell    - Django shell"
	@echo "  make migrate  - Run migrations"
	@echo "  make test     - Run tests"
	@echo "  make populate - Populate sample data"

build:
	docker-compose build

up:
	docker-compose up -d

down:
	docker-compose down

logs:
	docker-compose logs -f

shell:
	docker-compose exec django python manage.py shell

migrate:
	docker-compose exec django python manage.py migrate

test:
	docker-compose exec django pytest
	docker-compose exec fastapi pytest

populate:
	docker-compose exec django python scripts/populate_data.py
```

### Phase 5: CI/CD with GitHub Actions

#### 5.1 .github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: postgres
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
          
    steps:
    - uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
        
    - name: Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install -r src/django_app/requirements.txt
        pip install -r src/fastapi_app/requirements.txt
        
    - name: Run tests
      run: |
        pytest tests/
        
    - name: Build Docker images
      run: |
        docker-compose build
```

### Phase 6: Implementation Order

1. **Week 1: Core Setup**
   - Initialize repository
   - Set up Docker configuration
   - Create basic Django/FastAPI structure
   - Configure PostgreSQL and Redis

2. **Week 2: Models and APIs**
   - Create Django models
   - Implement FastAPI endpoints
   - Set up Celery tasks
   - Configure WebSocket connections

3. **Week 3: Frontend and Monitoring**
   - Build dashboard interface
   - Implement real-time charts
   - Add network scanning features
   - Integrate Netmiko

4. **Week 4: Testing and Deployment**
   - Write comprehensive tests
   - Set up CI/CD pipeline
   - Deploy to Raspberry Pi
   - Configure Cloudflare Tunnel

### Phase 7: Data Population Script
```python
# scripts/populate_data.py
"""
Populate the database with initial data and sample metrics
"""
import os
import sys
import django
import random
from datetime import datetime, timedelta

# Setup Django
sys.path.insert(0, '/app')
os.environ.setdefault('DJANGO_SETTINGS_MODULE', 'vandine_monitor.settings')
django.setup()

from network_monitor.models import NetworkDevice, SystemMetric, TunnelMetric

def create_devices():
    """Create network devices"""
    devices = [
        {
            'name': 'pi0',
            'ip_address': '192.168.2.10',
            'mac_address': 'd8:3a:dd:6b:9a:a1',
            'device_type': 'raspberry_pi',
            'hostname': 'pi0',
            'is_online': True,
            'services': {
                'syslog': {'port': 514, 'status': 'active'},
                'iperf3': {'port': 5201, 'status': 'active'},
                'http': {'port': 80, 'status': 'active'}
            }
        },
        {
            'name': 'pi1',
            'ip_address': '192.168.2.7',
            'mac_address': 'd8:3a:dd:89:ef:74',
            'device_type': 'raspberry_pi',
            'hostname': 'pi1.matrix.in',
            'is_online': True,
            'services': {
                'nginx': {'port': 80, 'status': 'active'},
                'ssh': {'port': 22, 'status': 'active'},
                'nfs': {'port': 2049, 'status': 'active'},
                'iperf3': {'port': 5201, 'status': 'active'}
            }
        },
        {
            'name': 'router',
            'ip_address': '192.168.2.1',
            'mac_address': 'f6:92:bf:1a:29:9e',
            'device_type': 'router',
            'hostname': 'unifi.vandine.in',
            'is_online': True,
            'services': {
                'ssh': {'port': 22, 'status': 'active'},
                'http': {'port': 80, 'status': 'active'},
                'https': {'port': 443, 'status': 'active'}
            }
        }
    ]
    
    for device_data in devices:
        device, created = NetworkDevice.objects.update_or_create(
            name=device_data['name'],
            defaults=device_data
        )
        print(f"{'Created' if created else 'Updated'} device: {device.name}")

def generate_sample_metrics():
    """Generate sample metrics for the last 24 hours"""
    devices = NetworkDevice.objects.all()
    now = datetime.now()
    
    for device in devices:
        for hours_ago in range(24, 0, -1):
            timestamp = now - timedelta(hours=hours_ago)
            
            # Create system metrics
            SystemMetric.objects.create(
                device=device,
                timestamp=timestamp,
                cpu_percent=random.uniform(10, 80),
                memory_percent=random.uniform(20, 70),
                disk_percent=random.uniform(30, 60),
                network_sent_mb=random.uniform(0, 100),
                network_recv_mb=random.uniform(0, 100),
                temperature=random.uniform(40, 70) if 'pi' in device.name else None,
                load_average=[
                    random.uniform(0.1, 2.0),
                    random.uniform(0.1, 2.0),
                    random.uniform(0.1, 2.0)
                ]
            )
        
        print(f"Generated metrics for {device.name}")

def generate_tunnel_metrics():
    """Generate sample tunnel metrics"""
    now = datetime.now()
    
    for hours_ago in range(24, 0, -1):
        timestamp = now - timedelta(hours=hours_ago)
        
        TunnelMetric.objects.create(
            timestamp=timestamp,
            tunnel_id='153cc7a6-9ab5-4172-b4cc-eb21e5b524cd',
            connections_active=4,
            total_requests=random.randint(1000, 50000),
            error_count=random.randint(0, 10),
            edge_locations=['LAX05', 'LAX06', 'LAX07'],
            latency_ms=random.uniform(10, 50)
        )
    
    print("Generated tunnel metrics")

if __name__ == '__main__':
    print("Populating database...")
    create_devices()
    generate_sample_metrics()
    generate_tunnel_metrics()
    print("Database population complete!")
```

### Phase 8: README.md
```markdown
# Vandine Network Monitor

A comprehensive network monitoring solution built with Django, FastAPI, and Docker, featuring real-time metrics, device management, and Cloudflare Tunnel integration.

## Features

- ğŸ–¥ï¸ Real-time system metrics monitoring
- ğŸŒ Network device discovery and management
- ğŸ“Š Interactive dashboards with Plotly
- ğŸ”§ SSH device management via Netmiko
- ğŸš€ High-performance API with FastAPI
- ğŸ”„ WebSocket support for live updates
- ğŸ³ Full Docker containerization
- ğŸ“ˆ Prometheus + Grafana integration
- ğŸ”’ Cloudflare Tunnel support

## Quick Start

1. Clone the repository:
```bash
git clone https://github.com/yourusername/vandine-network-monitor.git
cd vandine-network-monitor
```

2. Copy environment file:
```bash
cp .env.example .env
# Edit .env with your settings
```

3. Build and start services:
```bash
make build
make up
make migrate
make populate
```

4. Access the application:
- Dashboard: http://localhost
- FastAPI Docs: http://localhost/api/v1/docs
- Admin: http://localhost/admin

## Architecture

The project consists of:
- **Django**: Main web application and admin interface
- **FastAPI**: High-performance API and WebSocket server
- **PostgreSQL**: Primary database
- **Redis**: Cache and message broker
- **Celery**: Background task processing
- **Nginx**: Reverse proxy and static file serving

## Development

Run tests:
```bash
make test
```

Access Django shell:
```bash
make shell
```

View logs:
```bash
make logs
```

## Deployment

The application is designed to run on Raspberry Pi with Cloudflare Tunnel for secure external access.

See [DEPLOYMENT.md](docs/DEPLOYMENT.md) for detailed instructions.

## License

MIT License - see [LICENSE](LICENSE) for details.
```

## Next Steps

1. **Create GitHub Repository**:
   ```bash
   gh repo create vandine-network-monitor --public
   git add .
   git commit -m "Initial commit: Complete network monitoring solution"
   git push -u origin main
   ```

2. **Implement Core Features**:
   - Django models and admin
   - FastAPI endpoints
   - WebSocket connections
   - Celery tasks
   - Dashboard UI

3. **Add Monitoring**:
   - Prometheus metrics
   - Grafana dashboards
   - Custom alerts

4. **Deploy to Raspberry Pi**:
   - Build Docker images
   - Configure Cloudflare Tunnel
   - Set up systemd services

This comprehensive plan provides a solid foundation for building the network monitoring solution with all requested features!